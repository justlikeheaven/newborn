## 特点 ##
memcached是高性能的分布式内存缓冲服务器  
1. 协议简单（普通文本）  
2. 基于libevent事件  
3. 内置内存存储方式（全部数据存在内存里，基于LRU算法过期）  
4. 不互相通信的分布式（分布式交给客户端）

## 内存管理机制 ##
最近的memcached默认情况下采用了名为**Slab Allocator**的机制分配、管理内存。在该机制出现以 前，内存的分配是通过对所有记录简单地进行malloc和free来进行的。但是，这种方式会导致内存碎片，加重操作系统内存管理器的负担，最坏的情况下，会导致操作系统比memcached进程本身还 慢。Slab Allocator就是为解决该问题而诞生的。
![](http://up.2cto.com/os/201103/20110304120438975.png)
Slab Allocation的原理相当简单。它首先从操作系统申请一大块内存，并将其分割成各种尺寸的块Chunk，并把尺寸相同的块分成组Slab Class。其中，Chunk就是用来存储key-value数据的最小单位。每个Slab Class的大小，可以在Memcached启动的时候通过制定Growth Factor来控制。假定Figure 1中Growth Factor的取值为1.25，所以如果第一组Chunk的大小为88个字节，第二组Chunk的大小就为112个字节，依此类推。

当memcached接收到客户端发送过来的数据时首先会根据收到数据的大小选择一个最合适的Slab Class，然后通过查询Memcached保存着的该Slab Class内空闲Chunk的列表就可以找到一个可用于存储数据的Chunk。当一条数据库过期或者丢弃时，该记录所占用的Chunk就可以回收，重新添加到空闲列表中。从以上过程我们可以看出Memcached的内存管理制效率高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。因为每个 Chunk都分配了特定长度的内存空间，所以变长数据无法充分利用这些空间。如图所示，将100个字节的数据缓存到128个字节的Chunk中，剩余的28个字节就浪费掉了。

## 过期机制 ##
数据不会真正从 memcached中消失，上一章介绍过，memcached不会释放已分配的内存。记录超时后，客户端就无法再看见该记录 （invisible，透明），其存储空间即可重复使用。memcached内部不会监视记录是否过期，而是在get时查看记录的时间戳，检查记录是否过期。这 种技术被称为lazy（惰性）expiration。因此，memcached不会在过期监视上耗费CPU时间。

LRU：从缓存中有效删除数据的原理 memcached会优先使用已超时的记录的空间，但即使如此，也会发生追加新记录时空间不足的情况， 此时就要使用名为Least Recently Used（LRU）机制来分配空间。顾名思义，这是删除“最近最少使用”的记录的机制。因此，当memcached的内存空间不足时（无法从slab class获取到新的空间时），就从最近未被使用的记录中搜索，并将其空间分配给新的记录。从缓存的实用角度来看，该模型十分理想。 不过，有些情况下LRU机制反倒会造成麻烦。memcached启动时通过“­M”参数可以禁止LRU，memcached毕竟不是存储 器，而是缓存，所以推荐使用LRU